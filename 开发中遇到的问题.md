# 滚动位置
一个移动端的项目，首页和分类页面公用的一个查询接口，一个列表展示组件，都有上啦加载的功能，业务功能是一样，筛选场景不同，首页是推荐数据，分类页面是更具分类的筛选查询出来的数据，这两个页面都是tab页。

为了能够实现从列表点击跳转到详情页面后，在返回能够记录住当前列表页面的滚动位置，所以使用了缓存完成了列表位置和数据保存，为了能够使用户体验更加友好，所以将4个tab页面都做了缓存，这个时候出现了这样一个问题

在首页上啦加载更多，跳转到分类页面的时候发现分类页面直接加载了多页数据，经过仔细的研究发现是因为，首页和分类页面都是tab页面公用的是一个滚动条，当首页滚动了很长的时候，切换到分类页面，浏览器并不会自动调整滚动条的位置到对应的起始位置，所以自动触发了滚动到底部的行为，所以会加载很多数据，解决这个问题当时是使用了路由的滚动行为控制函数scrollBehavior，这个函数中接收三个参数，to，from，savedPosition，to是即将要去的路由的信息，form是要离开页面的路由信息，savedPosition是新页面是否有滚动位置保存的记录，但是savedPosition只能保存一级路由的滚动位置记录，所以又利用组件级的路由守卫，单独在对应路由组件中添加了beforeRouteLeave路由离开的导航守卫，在守卫函数中保存了当前页面的滚动条位置到当前页面的路由信息对象的meta对象中，这样就可以在scrollBehavior中获取到对应路由的滚动位置信息了，可以控制对应二级路由滚动条的位置。

但是这个时候又发现了新的问题，只有首页有滚动，分类页面就会直接从第二页开始加载数据，研究后发现是因为执行顺序的问题，是因为scrollBehavior是在组件的mounted之后才执行的，所以就永远会默认执行一些滚动触底的事件，解决这个问题，也是用了一个比较笨的方法，就是在beforeRouteLeave保存了当前页面滚动条位置以后，在控制滚动条回到0的位置，这样打开新页面的时候如果有滚动位置的记录就是滚动到对应位置，如果没有则就是0了

